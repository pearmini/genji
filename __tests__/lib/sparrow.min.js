(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sp = {}));
})(this, (function (exports) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  function createSVGElement(type) {
    return document.createElementNS('http://www.w3.org/2000/svg', type);
  }
  function applyAttributes(element, attributes) {
    for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      var kebabCaseKey = key.replace(/[A-Z]/g, function (d) {
        return "-".concat(d.toLocaleLowerCase());
      });
      element.setAttribute(kebabCaseKey, value);
    }
  }
  function applyTransform(element, transform) {
    var oldTransform = element.getAttribute('transform') || '';
    var prefix = oldTransform ? "".concat(oldTransform, " ") : '';
    element.setAttribute('transform', "".concat(prefix).concat(transform));
  }
  function mount(parent, child) {
    if (parent) {
      parent.appendChild(child);
    }
  }

  function createContext(width, height) {
    var svg = createSVGElement('svg');
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', "0 0 ".concat(width, " ").concat(height));
    var g = createSVGElement('g');
    mount(svg, g);
    return {
      node: svg,
      group: g
    };
  }

  var _excluded$8 = ["text"],
      _excluded2$1 = ["cx", "cy", "r1", "r2"];
  function line(context, attributes) {
    return shape('line', context, attributes);
  }
  function rect$1(context, attributes) {
    var width = attributes.width,
        height = attributes.height,
        x = attributes.x,
        y = attributes.y;
    return shape('rect', context, _objectSpread2(_objectSpread2({}, attributes), {}, {
      width: Math.abs(width),
      height: Math.abs(height),
      x: width > 0 ? x : x + width,
      y: height > 0 ? y : y + height
    }));
  }
  function path(context, attributes) {
    var d = attributes.d;
    return shape('path', context, _objectSpread2(_objectSpread2({}, attributes), {}, {
      d: d.flat().join(' ')
    }));
  }
  function circle(context, attributes) {
    return shape('circle', context, attributes);
  }
  function text(context, attributes) {
    var text = attributes.text,
        rest = _objectWithoutProperties(attributes, _excluded$8);

    var textElement = shape('text', context, rest);
    textElement.textContent = text;
    return textElement;
  }
  function ring(context, attributes) {
    var cx = attributes.cx,
        cy = attributes.cy,
        r1 = attributes.r1,
        r2 = attributes.r2,
        styles = _objectWithoutProperties(attributes, _excluded2$1);

    var stroke = styles.stroke,
        strokeWidth = styles.strokeWidth,
        fill = styles.fill;
    var defaultStrokeWidth = 1;
    var innerStroke = circle(context, {
      fill: 'transparent',
      stroke: stroke || fill,
      strokeWidth: strokeWidth,
      cx: cx,
      cy: cy,
      r: r1
    });
    var ring = circle(context, _objectSpread2(_objectSpread2({}, styles), {}, {
      strokeWidth: r2 - r1 - (strokeWidth || defaultStrokeWidth),
      stroke: fill,
      fill: 'transparent',
      cx: cx,
      cy: cy,
      r: (r1 + r2) / 2
    }));
    var outerStroke = circle(context, {
      fill: 'transparent',
      stroke: stroke || fill,
      strokeWidth: strokeWidth,
      cx: cx,
      cy: cy,
      r: r2
    });
    return [innerStroke, ring, outerStroke];
  }
  function shape(type, context, attributes) {
    var group = context.group;
    var el = createSVGElement(type);
    applyAttributes(el, attributes);
    mount(group, el);
    return el;
  }

  function translate$1(context, tx, ty) {
    transform$3('translate', context, tx, ty);
  }
  function rotate(context, theta) {
    transform$3('rotate', context, theta);
  }
  function scale$2(context, sx, sy) {
    transform$3('scale', context, sx, sy);
  }
  function save(context) {
    var group = context.group;
    var newGroup = createSVGElement('g');
    mount(group, newGroup);
    context.group = newGroup;
  }
  function restore(context) {
    var group = context.group;
    var parentNode = group.parentNode;
    context.group = parentNode;
  }

  function transform$3(type, context) {
    var group = context.group;

    for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      params[_key - 2] = arguments[_key];
    }

    applyTransform(group, "".concat(type, "(").concat(params.join(', '), ")"));
  }

  function createRenderer(width, height) {
    var context = createContext(width, height);
    return {
      line: function line$1(options) {
        return line(context, options);
      },
      circle: function circle$1(options) {
        return circle(context, options);
      },
      text: function text$1(options) {
        return text(context, options);
      },
      rect: function rect(options) {
        return rect$1(context, options);
      },
      path: function path$1(options) {
        return path(context, options);
      },
      ring: function ring$1(options) {
        return ring(context, options);
      },
      restore: function restore$1() {
        return restore(context);
      },
      save: function save$1() {
        return save(context);
      },
      scale: function scale() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return scale$2.apply(void 0, [context].concat(args));
      },
      rotate: function rotate$1() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return rotate.apply(void 0, [context].concat(args));
      },
      translate: function translate() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return translate$1.apply(void 0, [context].concat(args));
      },
      node: function node() {
        return context.node;
      },
      group: function group() {
        return context.group;
      }
    };
  }

  function identity(x) {
    return x;
  }
  function compose(fn) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    return rest.reduce(function (total, cur) {
      return function (x) {
        return cur(total(x));
      };
    }, fn);
  }

  function equal$2(_ref, _ref2) {
    var _ref3 = _slicedToArray(_ref, 2),
        x0 = _ref3[0],
        y0 = _ref3[1];

    var _ref4 = _slicedToArray(_ref2, 2),
        x1 = _ref4[0],
        y1 = _ref4[1];

    return closeTo(x0, x1) && closeTo(y0, y1);
  }
  function closeTo(x, y) {
    var tol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-5;
    return Math.abs(x - y) < tol;
  }
  function dist(_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        x0 = _ref6[0],
        y0 = _ref6[1];

    var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [],
        _ref8 = _slicedToArray(_ref7, 2),
        _ref8$ = _ref8[0],
        x1 = _ref8$ === void 0 ? 0 : _ref8$,
        _ref8$2 = _ref8[1],
        y1 = _ref8$2 === void 0 ? 0 : _ref8$2;

    return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
  }
  function sub(_ref9, _ref10) {
    var _ref11 = _slicedToArray(_ref9, 2),
        x1 = _ref11[0],
        y1 = _ref11[1];

    var _ref12 = _slicedToArray(_ref10, 2),
        x0 = _ref12[0],
        y0 = _ref12[1];

    return [x1 - x0, y1 - y0];
  } // TODO: refactor

  function angleBetween(v0, v1) {
    var a0 = angle(v0);
    var a1 = angle(v1);

    if (a0 >= 0 && a1 >= 0) {
      if (Math.abs(a0) < Math.abs(a1)) return Math.abs(a0 - a1);
      return Math.PI * 2 - Math.abs(a0 - a1);
    }

    if (a0 < 0 && a1 < 0) {
      if (Math.abs(a0) > Math.abs(a1)) return Math.abs(a0 - a1);
      return Math.PI * 2 - Math.abs(a0 - a1);
    }

    if (a0 < 0 && a1 > 0) return Math.abs(a0) + a1;
    return Math.PI * 2 - a0 - Math.abs(a1);
  }
  function angle(_ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        x = _ref14[0],
        y = _ref14[1];

    var theta = Math.atan2(y, x);
    return theta;
  }
  function fromDegree(radian) {
    return radian * 180 / Math.PI;
  }

  function createCoordinate(_ref) {
    var x = _ref.x,
        y = _ref.y,
        width = _ref.width,
        height = _ref.height,
        createTransforms = _ref.transforms;
    var coordinates = createTransforms.map(function (createTransform) {
      return createTransform({
        x: x,
        y: y,
        width: width,
        height: height
      });
    }).flat();
    var types = coordinates.map(function (d) {
      return d.type;
    });
    var transforms = coordinates.map(function (d) {
      return d.transform;
    });
    var output = transforms.length ? compose.apply(void 0, _toConsumableArray(transforms)) : identity;

    output.isPolar = function () {
      return types.indexOf('polar') !== -1;
    };

    output.isTranspose = function () {
      var count = types.filter(function (d) {
        return d === 'transpose';
      }).length;
      return count % 2 !== 0;
    };

    output.getCenter = function () {
      var cx = x + width / 2;
      var cy = y + height / 2;
      return [cx, cy];
    };

    return output;
  }

  function band$1(_ref) {
    var domain = _ref.domain,
        range = _ref.range,
        padding = _ref.padding;

    var _range = _slicedToArray(range, 2),
        r0 = _range[0],
        r1 = _range[1];

    var n = domain.length;
    var step = (r1 - r0) / (n + padding);
    var bandWidth = step * (1 - padding);
    var interval = step - bandWidth;
    return {
      step: step,
      bandWidth: bandWidth,
      bandRange: new Array(n).fill(0).map(function (_, i) {
        return r0 + interval + step * i;
      })
    };
  }
  function equal$1(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  }
  function normalize(value, start, stop) {
    return (value - start) / (stop - start);
  }
  function ceil(n, base) {
    return base * Math.ceil(n / base);
  }
  function floor(n, base) {
    return base * Math.floor(n / base);
  }
  function round(n) {
    return Math.round(n * 1e12) / 1e12;
  }
  function tickStep(min, max, count) {
    var e10 = Math.sqrt(50);
    var e5 = Math.sqrt(10);
    var e2 = Math.sqrt(2);
    var step0 = Math.abs(max - min) / Math.max(0, count);
    var step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10));
    var error = step0 / step1;
    if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
    return step1;
  }
  function nice(domain, interval) {
    var _domain = _slicedToArray(domain, 2),
        min = _domain[0],
        max = _domain[1];

    return [interval.floor(min), interval.ceil(max)];
  }
  function ticks(min, max, count) {
    var step = tickStep(min, max, count);
    var start = Math.ceil(min / step);
    var stop = Math.floor(max / step);
    var n = Math.ceil(stop - start + 1);
    var values = new Array(n);

    for (var i = 0; i < n; i += 1) {
      values[i] = round((start + i) * step);
    }

    return values;
  }

  function createLinear(_ref) {
    var _ref$domain = _slicedToArray(_ref.domain, 2),
        d0 = _ref$domain[0],
        d1 = _ref$domain[1],
        _ref$range = _slicedToArray(_ref.range, 2),
        r0 = _ref$range[0],
        r1 = _ref$range[1],
        _ref$interpolate = _ref.interpolate,
        interpolate = _ref$interpolate === void 0 ? interpolateNumber : _ref$interpolate;

    var scale = function scale(x) {
      var t = normalize(x, d0, d1);
      return interpolate(t, r0, r1);
    };

    scale.ticks = function (tickCount) {
      return ticks(d0, d1, tickCount);
    };

    scale.nice = function (tickCount) {
      var step = tickStep(d0, d1, tickCount);

      var _nice = nice([d0, d1], {
        floor: function floor$1(x) {
          return floor(x, step);
        },
        ceil: function ceil$1(x) {
          return ceil(x, step);
        }
      });

      var _nice2 = _slicedToArray(_nice, 2);

      d0 = _nice2[0];
      d1 = _nice2[1];
    };

    return scale;
  }
  function interpolateNumber(t, start, stop) {
    return start * (1 - t) + stop * t;
  }

  function createIdentity() {
    return function (x) {
      return x;
    };
  }

  function createOrdinal(_ref) {
    var domain = _ref.domain,
        range = _ref.range;
    return function (x) {
      var index = domain.findIndex(function (d) {
        return equal$1(d, x);
      });
      return range[index % range.length];
    };
  }

  function createBand(options) {
    var _band = band$1(options),
        bandRange = _band.bandRange,
        bandWidth = _band.bandWidth,
        step = _band.step;

    var scale = createOrdinal(_objectSpread2(_objectSpread2({}, options), {}, {
      range: bandRange
    }));

    scale.bandWidth = function () {
      return bandWidth;
    };

    scale.step = function () {
      return step;
    };

    return scale;
  }

  function createConstant(_ref) {
    var _ref$domain = _slicedToArray(_ref.domain, 1),
        d = _ref$domain[0];

    return function () {
      return d;
    };
  }

  function cartesian() {
    return function (_ref) {
      var x = _ref.x,
          y = _ref.y,
          width = _ref.width,
          height = _ref.height;
      return transform$2(x, y, width, height);
    };
  }

  function transform$2(x, y, width, height) {
    var tx = createLinear({
      domain: [0, 1],
      range: [x, x + width]
    });
    var ty = createLinear({
      domain: [0, 1],
      range: [y, y + height]
    });
    return {
      type: 'cartesian',
      transform: function transform(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            px = _ref3[0],
            py = _ref3[1];

        return [tx(px), ty(py)];
      }
    };
  }

  function translate() {
    var tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return {
      type: 'translate',
      transform: function transform(_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            px = _ref2[0],
            py = _ref2[1];

        return [px + tx, py + ty];
      }
    };
  }
  function reflectX() {
    return {
      type: 'reflectX',
      transform: function transform(_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            px = _ref6[0],
            py = _ref6[1];

        return [px * -1, py];
      }
    };
  }
  function reflectY() {
    return {
      type: 'reflectY',
      transform: function transform(_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            px = _ref8[0],
            py = _ref8[1];

        return [px, py * -1];
      }
    };
  }
  function scale$1() {
    var sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return {
      type: 'scale',
      transform: function transform(_ref9) {
        var _ref10 = _slicedToArray(_ref9, 2),
            px = _ref10[0],
            py = _ref10[1];

        return [px * sx, py * sy];
      }
    };
  }

  function polar$1(options) {
    return function (_ref) {
      var width = _ref.width,
          height = _ref.height;
      var aspect = width / height;
      var sx = aspect > 1 ? 1 / aspect : 1;
      var sy = aspect > 1 ? 1 : aspect;
      return [translate(0, -0.5), reflectY(), translate(0, 0.5), transform$1(options), scale$1(sx, sy), scale$1(0.5, 0.5), translate(0.5, 0.5)];
    };
  }

  function transform$1(_ref2) {
    var innerRadius = _ref2.innerRadius,
        outerRadius = _ref2.outerRadius,
        startAngle = _ref2.startAngle,
        endAngle = _ref2.endAngle;
    var radius = createLinear({
      domain: [0, 1],
      range: [innerRadius, outerRadius]
    });
    var angle = createLinear({
      domain: [0, 1],
      range: [startAngle, endAngle]
    });
    return {
      type: 'polar',
      transform: function transform(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            px = _ref4[0],
            py = _ref4[1];

        var theta = angle(px);
        var r = radius(py);
        var vx = r * Math.cos(theta);
        var vy = r * Math.sin(theta);
        return [vx, vy];
      }
    };
  }

  function transpose$1() {
    return function () {
      return [transform(), translate(-0.5, -0.5), reflectX(), translate(0.5, 0.5)];
    };
  }

  function transform() {
    return {
      type: 'transpose',
      transform: function transform(_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            px = _ref2[0],
            py = _ref2[1];

        return [py, px];
      }
    };
  }

  function range(data) {
    return data.map(function (_, i) {
      return i;
    });
  }
  function fromObject(array, key, value) {
    return array.reduce(function (obj, item) {
      return obj[key(item)] = value(item), obj;
    }, {});
  }
  function unique(array) {
    return array.filter(function (d, index) {
      return array.findIndex(function (a) {
        return equal(d, a);
      }) === index;
    });
  }
  function equal(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  }
  function min(array, accessor) {
    return Math.min.apply(Math, _toConsumableArray(array.map(accessor)));
  }
  function max(array, accessor) {
    return Math.max.apply(Math, _toConsumableArray(array.map(accessor)));
  }

  var colors = ['#5B8FF9', '#5AD8A6', '#5D7092', '#F6BD16', '#6F5EF9', '#6DC8EC', '#945FB9', '#FF9845', '#1E9493', '#FF99C3'];

  var _excluded$7 = ["type"];
  function fromTransform(options) {
    var transforms = options.map(function (_ref) {
      var type = _ref.type,
          options = _objectWithoutProperties(_ref, _excluded$7);

      return creator(type)(options);
    });
    transforms.push(cartesian());
    return transforms;
  }
  function isPolar(transforms) {
    return transforms.some(function (d) {
      return d.type === 'polar';
    });
  }
  function isTranspose(transforms) {
    var count = transforms.filter(function (d) {
      return d.type === 'transpose';
    }).length;
    return count % 2 === 1;
  }

  function creator(type) {
    var typeCreator = {
      polar: polar$1,
      transpose: transpose$1
    };
    var c = typeCreator[type];
    if (c) return c;
    throw new Error("unknown coordinate type: ".concat(type));
  }

  var _excluded$6 = ["channel"],
      _excluded2 = ["nice", "tickCount"],
      _excluded3 = ["domain", "range"];
  function createScales(values, channels, transforms, optionsA) {
    var optionsO = fromObject(optionsA, function (d) {
      return d.channel;
    }, function (_ref) {
      _ref.channel;
          var rest = _objectWithoutProperties(_ref, _excluded$6);

      return _objectSpread2({}, rest);
    });
    var scaleDescriptors = values.map(function (_ref2) {
      var value = _ref2.value,
          name = _ref2.channel;
      return _objectSpread2({
        name: name,
        scale: channels[name].scale
      }, inferScale(value, channels[name], transforms, optionsO[name]));
    });
    syncScales(scaleDescriptors);
    var scales = scaleDescriptors.reduce(function (obj, _ref3) {
      var name = _ref3.name,
          creator = _ref3.creator,
          options = _ref3.options;

      var nice = options.nice,
          _options$tickCount = options.tickCount,
          tickCount = _options$tickCount === void 0 ? 5 : _options$tickCount,
          rest = _objectWithoutProperties(options, _excluded2);

      var scale = creator(rest);
      if (nice && scale.nice) scale.nice(tickCount);
      obj[name] = scale;
      return obj;
    }, {});
    return [scaleDescriptors, scales];
  }
  function applyScales(values, scales) {
    return values.reduce(function (obj, _ref4) {
      var value = _ref4.value,
          channel = _ref4.channel;
      return obj[channel] = value.map(scales[channel]), obj;
    }, {});
  }

  function inferScale(value, channel, transforms) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    switch (inferScaleType(value, channel, options)) {
      case 'band':
        return inferBand(value, channel, transforms, options);

      case 'linear':
        return inferLinear(value, channel, transforms, options);

      case 'ordinal':
        return inferOrdinal(value, channel, transforms, options);

      case 'constant':
        return inferConstant(value, channel, transforms);

      case 'identity':
        return inferIdentity();

      default:
        throw new Error("unknown scale type: ".concat(options.type));
    }
  }

  function syncScales(scaleDescriptors) {
    var x = scaleDescriptors.filter(function (_ref5) {
      var type = _ref5.type,
          scale = _ref5.scale;
      return type === 'quantitative' && scale === 'x';
    });
    var y = scaleDescriptors.filter(function (_ref6) {
      var type = _ref6.type,
          scale = _ref6.scale;
      return type === 'quantitative' && scale === 'y';
    });
    if (x.length > 1) syncScaleQ(x);
    if (y.length > 1) syncScaleQ(y);
  }

  function syncScaleQ(scaleDescriptors) {
    var d0 = min(scaleDescriptors, function (_ref7) {
      var domain = _ref7.options.domain;
      return domain[0];
    });
    var d1 = max(scaleDescriptors, function (_ref8) {
      var domain = _ref8.options.domain;
      return domain[domain.length - 1];
    });
    var r0 = min(scaleDescriptors, function (_ref9) {
      var range = _ref9.options.range;
      return range[0];
    });
    var r1 = max(scaleDescriptors, function (_ref10) {
      var range = _ref10.options.range;
      return range[range.length - 1];
    });
    var nice = scaleDescriptors.some(function (_ref11) {
      var nice = _ref11.options.nice;
      return nice === true;
    });

    var _iterator = _createForOfIteratorHelper(scaleDescriptors),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var descriptor = _step.value;
        descriptor.options.domain = [d0, d1];
        descriptor.options.range = [r0, r1];
        descriptor.options.nice = nice;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  function inferScaleType(value, channel, option) {
    var constant = value.constant;
    var scaleType = channel.scaleType;
        channel.type;
        var scale = channel.scale;
    var customScaleType = option.type,
        domain = option.domain,
        range = option.range;
    if (constant && scale === 'color') return 'constant';
    if (scaleType) return scaleType;
    if (customScaleType) return customScaleType;
    if ((domain || range || []).length > 2) return asOrdinalType();

    if (domain !== undefined) {
      if (isOrdinal(domain)) return asOrdinalType();
      return 'linear';
    }

    if (isOrdinal(value)) return asOrdinalType();
    return 'linear';
  }

  function inferBand(value, channel, transforms, _ref12) {
    var _ref12$domain = _ref12.domain,
        domain = _ref12$domain === void 0 ? inferDomainO(value) : _ref12$domain,
        _ref12$range = _ref12.range,
        range = _ref12$range === void 0 ? [0, 1] : _ref12$range,
        _ref12$padding = _ref12.padding,
        padding = _ref12$padding === void 0 ? isPolar(transforms) ? 0 : 0.1 : _ref12$padding;
    return {
      creator: createBand,
      type: 'ordinal',
      options: {
        domain: domain,
        range: range,
        padding: padding
      }
    };
  }

  function inferOrdinal(value, _ref13, transforms, _ref14) {
    var scale = _ref13.scale;
    var _ref14$domain = _ref14.domain,
        domain = _ref14$domain === void 0 ? inferDomainO(value) : _ref14$domain,
        _ref14$range = _ref14.range,
        range = _ref14$range === void 0 ? scale === 'color' ? colors : undefined : _ref14$range;
    return {
      creator: createOrdinal,
      type: 'ordinal',
      options: {
        domain: domain,
        range: range
      }
    };
  }

  function inferLinear(value, _ref15, transforms, _ref16) {
    var scale = _ref15.scale;

    var _ref16$domain = _ref16.domain,
        domain = _ref16$domain === void 0 ? inferDomainQ(value) : _ref16$domain,
        _ref16$range = _ref16.range,
        range = _ref16$range === void 0 ? scale === 'y' ? [1, 0] : [0, 1] : _ref16$range,
        rest = _objectWithoutProperties(_ref16, _excluded3);

    return {
      creator: createLinear,
      type: 'quantitative',
      options: _objectSpread2({
        domain: domain,
        range: range
      }, rest)
    };
  }

  function inferConstant(_ref17, scale, _ref18) {
    var _ref19 = _slicedToArray(_ref17, 1),
        v = _ref19[0];

    var _ref18$domain = _ref18.domain,
        domain = _ref18$domain === void 0 ? [v] : _ref18$domain,
        _ref18$range = _ref18.range,
        range = _ref18$range === void 0 ? [v] : _ref18$range;
    return {
      creator: createConstant,
      type: isOrdinal([v]) ? 'ordinal' : 'quantitative',
      options: {
        domain: domain,
        range: range
      }
    };
  }

  function inferIdentity() {
    return {
      creator: createIdentity,
      type: 'identity',
      options: {}
    };
  }

  function inferDomainQ(value) {
    return [Math.min.apply(Math, _toConsumableArray(value)), Math.max.apply(Math, _toConsumableArray(value))];
  }

  function inferDomainO(value) {
    return unique(value);
  }

  function asOrdinalType() {
    return 'ordinal';
  }

  function isOrdinal(value) {
    return value.some(function (d) {
      return typeof d === 'string' || typeof d === 'boolean';
    });
  }

  var _excluded$5 = ["optional"];
  function createChannel(_ref) {
    var _ref$optional = _ref.optional,
        optional = _ref$optional === void 0 ? true : _ref$optional,
        rest = _objectWithoutProperties(_ref, _excluded$5);

    return _objectSpread2({
      optional: optional
    }, rest);
  }
  function createPositionChannel(options) {
    return createChannel(_objectSpread2({
      type: 'position'
    }, options));
  }
  function createXChannel(options) {
    return createPositionChannel(_objectSpread2({
      scale: 'x'
    }, options));
  }
  function createYChannel(options) {
    return createPositionChannel(_objectSpread2({
      scale: 'y'
    }, options));
  }
  function createColorChannel(options) {
    return createChannel(_objectSpread2({
      scale: 'color',
      type: 'color'
    }, options));
  }
  function createLabelChannel(options) {
    return createChannel(_objectSpread2({
      scale: 'text',
      scaleType: 'identity',
      type: 'text'
    }, options));
  }

  var _excluded$4 = ["formatter"];
  function rect(renderer, _ref, coordinate, styles) {
    var _ref2 = _slicedToArray(_ref, 4),
        v0 = _ref2[0],
        v1 = _ref2[1],
        v2 = _ref2[2],
        v3 = _ref2[3];

    if (!coordinate.isPolar()) {
      var _map = [v0, v2].map(coordinate),
          _map2 = _slicedToArray(_map, 2),
          p0 = _map2[0],
          p2 = _map2[1];

      var _sub = sub(p2, p0),
          _sub2 = _slicedToArray(_sub, 2),
          w = _sub2[0],
          h = _sub2[1];

      return renderer.rect(_objectSpread2(_objectSpread2({}, styles), {}, {
        x: p0[0],
        y: p0[1],
        width: w,
        height: h
      }));
    }

    var center = coordinate.getCenter();
    var vs = coordinate.isTranspose() ? [v3, v0, v1, v2] : [v0, v1, v2, v3];
    var ps = vs.map(coordinate);

    if (!colline.apply(void 0, _toConsumableArray(ps))) {
      var d = arcPath.apply(void 0, [center].concat(_toConsumableArray(ps)));
      return renderer.path(_objectSpread2(_objectSpread2({}, styles), {}, {
        d: d
      }));
    }

    var r1 = dist(center, ps[2]);
    var r2 = dist(center, ps[0]);
    return renderer.ring(_objectSpread2({
      cx: center[0],
      cy: center[1],
      r1: r1,
      r2: r2
    }, styles));
  }
  function rectLabel(renderer, label, _ref3, coordinate, styles) {
    var _ref4 = _slicedToArray(_ref3, 3),
        v0 = _ref4[0],
        v2 = _ref4[2];

    var vx = (v0[0] + v2[0]) / 2;
    var vy = (v0[1] + v2[1]) / 2;

    var _coordinate = coordinate([vx, vy]),
        _coordinate2 = _slicedToArray(_coordinate, 2),
        x = _coordinate2[0],
        y = _coordinate2[1];

    var _styles$formatter = styles.formatter,
        formatter = _styles$formatter === void 0 ? function (d) {
      return "".concat(d);
    } : _styles$formatter,
        rest = _objectWithoutProperties(styles, _excluded$4);

    return renderer.text(_objectSpread2({
      x: x,
      y: y,
      text: formatter(label),
      textAnchor: 'middle'
    }, rest));
  }
  function colline(p0, p1, p2, p3) {
    return equal$2(p0, p1) && equal$2(p2, p3);
  }
  function arcPath(c, p0, p1, p2, p3) {
    var r = dist(c, p0);
    var r1 = dist(c, p2);
    var a = angleBetween(sub(p0, c), sub(p1, c));
    var l = a > Math.PI ? 1 : 0;
    var l1 = a > Math.PI ? 1 : 0;
    return [['M', p0[0], p0[1]], ['A', r, r, 0, l, 1, p1[0], p1[1]], ['L', p2[0], p2[1]], ['A', r1, r1, 0, l1, 0, p3[0], p3[1]], ['Z']];
  }
  function fromStyles(styles) {
    var geometryStyles = {};
    var labelStyles = {};

    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      if (key.startsWith('label')) {
        var labelKey = toLowerCase(key.replace('label', ''));
        labelStyles[labelKey] = value;
      } else {
        geometryStyles[key] = value;
      }
    }

    return [geometryStyles, labelStyles];
  }
  function toLowerCase(string) {
    var a = string.slice(0, 1);
    var b = string.slice(1);
    return a.toLowerCase() + b;
  }

  function createInterval() {
    var render = function render(_ref) {
      var renderer = _ref.renderer,
          index = _ref.index,
          values = _ref.values,
          directStyles = _ref.directStyles,
          scales = _ref.scales,
          coordinate = _ref.coordinate;
      var F = values.fill,
          S = values.stroke,
          X = values.x,
          Y = values.y,
          Y1 = values.y1,
          L = values.label;
      var x = scales.x;
      var width = x ? x.bandWidth() : 1;
      return index.map(function (i) {
        var vx = X[i] || 0;
        var label = L && L[i];

        var styles = _objectSpread2(_objectSpread2(_objectSpread2({}, directStyles), S && {
          stroke: S[i]
        }), F && {
          fill: F[i]
        });

        var _fromStyles = fromStyles(styles),
            _fromStyles2 = _slicedToArray(_fromStyles, 2),
            geometryStyles = _fromStyles2[0],
            labelStyles = _fromStyles2[1];

        var v0 = [vx, Y[i]];
        var v1 = [v0[0] + width, v0[1]];
        var v2 = [v1[0], Y1[i]];
        var v3 = [v0[0], Y1[i]];
        var points = [v0, v1, v2, v3];
        var rects = rect(renderer, points, coordinate, geometryStyles);
        if (label !== undefined) rectLabel(renderer, label, points, coordinate, labelStyles);
        return rects;
      });
    };

    render.channels = function () {
      return {
        x: createXChannel({
          name: 'x',
          scaleType: 'band',
          optional: false
        }),
        y: createYChannel({
          name: 'y',
          optional: false
        }),
        y1: createYChannel({
          name: 'y1',
          optional: false
        }),
        fill: createColorChannel({
          name: 'fill'
        }),
        stroke: createColorChannel({
          name: 'stroke'
        }),
        label: createLabelChannel({
          name: 'label'
        })
      };
    };

    return render;
  }

  function fromGeometry(type) {
    if (type === 'interval') return createInterval();
    throw new Error("unknown interval type: ".concat(type));
  }

  function valuesOf(data, encodes, channels) {
    var values = Array.from(encodes, function (encode) {
      return {
        channel: encode.channel,
        value: valueOf(data, encode)
      };
    });
    var names = new Set(encodes.map(function (d) {
      return d.channel;
    }));

    for (var _i = 0, _Object$entries = Object.entries(channels); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          optional = _Object$entries$_i[1].optional;

      if (!optional && !names.has(key)) {
        throw new Error("Missing encoding for ".concat(key, "."));
      }
    }

    return values;
  }
  function valueOf(data, _ref) {
    var channel = _ref.channel,
        transform = _ref.transform,
        value = _ref.value,
        field = _ref.field;
    if (field !== undefined) return Array.from(data, function (d) {
      return d[field];
    });
    if (transform !== undefined) return Array.from(data, transform);

    if (value !== undefined) {
      var v = Array.from(data, function () {
        return value;
      });
      v.constant = true;
      return v;
    }

    throw new Error("Bad encoding for channel ".concat(channel, "."));
  }

  function measureTextByDOM(text) {
    var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      fontSize: 12
    };
    var span = createSpan();
    span.style.fontSize = "".concat(font.fontSize, "px");
    span.style.fontFamily = font.fontFamily;
    span.style.fontWeight = font.fontWeight;
    span.style.fontStyle = font.fontStyle;
    span.style.fontVariant = font.fontVariant;
    span.innerHTML = text;
    return [span.clientWidth, span.clientHeight];
  }
  var measureTextSpan;

  function createSpan() {
    if (measureTextSpan) return measureTextSpan;
    measureTextSpan = document.createElement('span'); // 不显示在视窗

    measureTextSpan.style.visibility = 'hidden';
    measureTextSpan.style.position = 'absolute';
    measureTextSpan.style.display = 'inline';
    measureTextSpan.style.left = '-10000px';
    measureTextSpan.style.top = '-10000px';
    document.body.appendChild(measureTextSpan);
    return measureTextSpan;
  }

  function calcDimensions(_ref, _ref2, transforms) {
    var xTicks = _ref.x,
        yTicks = _ref.y;
    var xTitle = _ref2.x,
        yTitle = _ref2.y;

    var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref3$width = _ref3.width,
        width = _ref3$width === void 0 ? 640 : _ref3$width,
        _ref3$height = _ref3.height,
        height = _ref3$height === void 0 ? 480 : _ref3$height,
        _ref3$marginLeft = _ref3.marginLeft,
        marginLeft = _ref3$marginLeft === void 0 ? 30 : _ref3$marginLeft,
        _ref3$marginRight = _ref3.marginRight,
        marginRight = _ref3$marginRight === void 0 ? 30 : _ref3$marginRight,
        _ref3$marginBottom = _ref3.marginBottom,
        marginBottom = _ref3$marginBottom === void 0 ? 40 : _ref3$marginBottom,
        _ref3$marginTop = _ref3.marginTop,
        marginTop = _ref3$marginTop === void 0 ? 40 : _ref3$marginTop;

    if (!isPolar(transforms)) {
      var ticks = isTranspose(transforms) ? xTicks : yTicks;
      var title = isTranspose(transforms) ? xTitle : yTitle;
      var texts = showTitle$1(title) ? [].concat(_toConsumableArray(ticks), [title]) : ticks;
      if (texts) marginLeft = calcMarginLeft(texts);
    }

    return {
      width: width,
      height: height,
      marginLeft: marginLeft,
      marginRight: marginRight,
      marginTop: marginTop,
      marginBottom: marginBottom,
      chartWidth: width - marginLeft - marginRight,
      chartHeight: height - marginTop - marginBottom
    };
  }

  function calcMarginLeft(ticks) {
    var widths = ticks.map(function (d) {
      return measureTextByDOM(d)[0];
    });
    return Math.max.apply(Math, _toConsumableArray(widths)) + 20;
  }

  function showTitle$1(title) {
    return title !== undefined && title !== false;
  }

  function patchEncode(type, encode) {
    if (type === 'interval') return inferInterval(encode);
    return encode;
  }

  function inferInterval(encode) {
    var patchEncode = _toConsumableArray(encode);

    if (!has(encode, 'y1')) patchEncode.push({
      channel: 'y1',
      value: 0
    });
    if (!has(encode, 'x')) patchEncode.push({
      channel: 'x',
      value: 0
    });
    return patchEncode;
  }

  function has(encode, channel) {
    return encode.findIndex(function (d) {
      return d.channel === channel;
    }) !== -1;
  }

  function group(data, key) {
    var groups = new Map();

    var _iterator = _createForOfIteratorHelper(data),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var d = _step.value;
        var k = key(d);

        if (groups.has(k)) {
          var values = groups.get(k);
          values.push(d);
        } else {
          groups.set(k, [d]);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return groups;
  }

  function createStack(_ref) {
    var x = _ref.x,
        y = _ref.y,
        y1 = _ref.y1;
    return function (_ref2) {
      var _objectSpread2$1;

      var _ref3 = _slicedToArray(_ref2, 2),
          index = _ref3[0],
          values = _ref3[1];

      var X = values[x];
      var Y = values[y];
      var stacks = Array.from(group(index, function (i) {
        return X[i];
      }).values());
      var newY = new Array(index.length);
      var newY1 = new Array(index.length);

      for (var _i = 0, _stacks = stacks; _i < _stacks.length; _i++) {
        var stack = _stacks[_i];
        var py = 0;

        var _iterator = _createForOfIteratorHelper(stack),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var i = _step.value;
            newY1[i] = py;
            newY[i] = py + Y[i];
            py = newY[i];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return [index, _objectSpread2(_objectSpread2({}, values), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, y, newY), _defineProperty(_objectSpread2$1, y1, newY1), _objectSpread2$1))];
    };
  }

  var _excluded$3 = ["type"];
  function applyStatistics(index, values, geometryType, descriptors) {
    var objectValues = fromObject(values, function (d) {
      return d.channel;
    }, function (d) {
      return d.value;
    });
    var statistics = descriptors.map(function (options) {
      return createStatistics(geometryType, options);
    });
    var transform = statistics.length ? compose.apply(void 0, _toConsumableArray(statistics)) : identity;

    var _transform = transform([index, objectValues]),
        _transform2 = _slicedToArray(_transform, 2),
        transformedValues = _transform2[1];

    return Object.entries(transformedValues).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      return {
        channel: key,
        value: value
      };
    });
  }

  function createStatistics(geometryType, _ref3) {
    var type = _ref3.type,
        options = _objectWithoutProperties(_ref3, _excluded$3);

    if (type === 'stack') return createStack(inferStack(geometryType, options));
    throw new Error("unknown statistics type: ".concat(type));
  }

  function inferStack(geometryType, _ref4) {
    var _ref4$x = _ref4.x,
        x = _ref4$x === void 0 ? 'x' : _ref4$x,
        _ref4$y = _ref4.y,
        y = _ref4$y === void 0 ? 'y' : _ref4$y,
        _ref4$y2 = _ref4.y1,
        y1 = _ref4$y2 === void 0 ? 'y1' : _ref4$y2;
    return {
      x: x,
      y: y,
      y1: y1
    };
  }

  var _excluded$2 = ["renderer", "ticks", "values", "coordinate", "isCircular", "isVertical", "verticalDy", "circularDy", "horizontalDy"];
  function axis(_ref) {
    var renderer = _ref.renderer,
        ticks = _ref.ticks,
        values = _ref.values,
        coordinate = _ref.coordinate,
        isCircular = _ref.isCircular,
        isVertical = _ref.isVertical,
        verticalDy = _ref.verticalDy,
        circularDy = _ref.circularDy,
        horizontalDy = _ref.horizontalDy,
        options = _objectWithoutProperties(_ref, _excluded$2);

    for (var i = 0; i < ticks.length; i += 1) {
      var _ticks$i = _slicedToArray(ticks[i], 2),
          x = _ticks$i[0],
          y = _ticks$i[1];

      var label = values[i];

      var _ref2 = isCircular ? rotationOf([x, y], coordinate) : [0, 0],
          _ref3 = _slicedToArray(_ref2, 2),
          tickRotation = _ref3[0],
          textRotation = _ref3[1];

      var dy = isVertical ? verticalDy : isCircular && textRotation ? circularDy : horizontalDy;
      tick(_objectSpread2({
        renderer: renderer,
        x: x,
        y: y,
        dy: dy,
        label: label,
        tickRotation: tickRotation,
        textRotation: textRotation
      }, options));
    }
  }
  function tick(_ref4) {
    var renderer = _ref4.renderer,
        x = _ref4.x,
        y = _ref4.y,
        x2 = _ref4.x2,
        y2 = _ref4.y2,
        _ref4$dx = _ref4.dx,
        dx = _ref4$dx === void 0 ? 0 : _ref4$dx,
        _ref4$dy = _ref4.dy,
        dy = _ref4$dy === void 0 ? 0 : _ref4$dy,
        _ref4$label = _ref4.label,
        label = _ref4$label === void 0 ? '' : _ref4$label,
        _ref4$textRotation = _ref4.textRotation,
        textRotation = _ref4$textRotation === void 0 ? 0 : _ref4$textRotation,
        _ref4$tickRotation = _ref4.tickRotation,
        tickRotation = _ref4$tickRotation === void 0 ? 0 : _ref4$tickRotation,
        _ref4$textAnchor = _ref4.textAnchor,
        textAnchor = _ref4$textAnchor === void 0 ? 'middle' : _ref4$textAnchor,
        _ref4$fontSize = _ref4.fontSize,
        fontSize = _ref4$fontSize === void 0 ? '12' : _ref4$fontSize;
    renderer.save();
    renderer.translate(x, y);
    renderer.rotate(fromDegree(tickRotation));
    renderer.line({
      x1: 0,
      y1: 0,
      x2: x2,
      y2: y2,
      stroke: 'currentColor',
      fill: 'currentColor'
    });
    renderer.save();
    renderer.translate(x2, y2);
    renderer.rotate(fromDegree(textRotation));
    renderer.text({
      text: "".concat(label),
      x: 0,
      y: 0,
      textAnchor: textAnchor,
      dy: "".concat(dy, "em"),
      dx: "".concat(dx, "em"),
      fontSize: fontSize,
      fill: 'currentColor'
    });
    renderer.restore();
    renderer.restore();
  }
  function ticksOf$1(values, scale, coordinate, isVertical, y) {
    var offset = scale.bandWidth ? scale.bandWidth() / 2 : 0;
    var points = values.map(function (d) {
      var x = scale(d) + offset;
      return isVertical ? [y, x] : [x, y];
    });
    var ticks = points.map(coordinate);
    return ticks.filter(function (d, index) {
      return ticks.findIndex(function (a) {
        return equal$2(d, a);
      }) === index;
    });
  }
  function titleOf(_ref5, coordinate, title, direction) {
    var _ref6 = _slicedToArray(_ref5, 2),
        x = _ref6[0],
        y = _ref6[1];

    var _coordinate = coordinate([x, y]),
        _coordinate2 = _slicedToArray(_coordinate, 2),
        tx = _coordinate2[0],
        ty = _coordinate2[1];

    var formatter = function formatter(d) {
      if (direction === 'up') return "\u2191 ".concat(d);
      if (direction === 'right') return "".concat(d, " \u2192");
      return "\u2193 ".concat(d);
    };

    return [[tx, ty], formatter(title)];
  }
  function rotationOf(_ref7, coordinate) {
    var _ref8 = _slicedToArray(_ref7, 2),
        x = _ref8[0],
        y = _ref8[1];

    var center = coordinate.getCenter();
    var tickRotation = angle(sub([x, y], center));
    var textRotation = tickRotation < 0 ? Math.PI : 0;
    return [tickRotation - Math.PI / 2, textRotation];
  }
  function axisBottomOptions(tickLength) {
    return {
      textAnchor: 'middle',
      x2: 0,
      y2: tickLength,
      dx: 0,
      verticalDy: 0.3,
      horizontalDy: 1,
      circularDy: -0.6
    };
  }
  function axisLeftOptions(tickLength) {
    return {
      textAnchor: 'end',
      x2: -tickLength,
      y2: 0,
      dx: -0.3,
      verticalDy: 0.3,
      horizontalDy: 1,
      circularDy: 0.6
    };
  }
  function axisTopOptions(tickLength) {
    return {
      textAnchor: 'middle',
      x2: 0,
      y2: -tickLength,
      dx: 0,
      verticalDy: 0.3,
      horizontalDy: -0.2,
      circularDy: -0.6
    };
  }
  function showTitle(title, coordinate) {
    return title !== undefined && title && !coordinate.isPolar();
  }

  function axisX$1(_ref) {
    var renderer = _ref.renderer,
        scale = _ref.scale,
        values = _ref.values,
        coordinate = _ref.coordinate,
        title = _ref.title,
        _ref$tickLength = _ref.tickLength,
        tickLength = _ref$tickLength === void 0 ? 5 : _ref$tickLength;
    var y = coordinate.isPolar() ? 0 : 1;
    var ticks = ticksOf$1(values, scale, coordinate, false, y);
    var isCircular = coordinate.isPolar() && !coordinate.isTranspose();
    var isVertical = coordinate.isTranspose();
    var axisOptions = isVertical ? axisLeftOptions(tickLength) : axisBottomOptions(tickLength);
    axis(_objectSpread2({
      renderer: renderer,
      ticks: ticks,
      values: values,
      coordinate: coordinate,
      isCircular: isCircular,
      isVertical: isVertical
    }, axisOptions));

    if (showTitle(title, coordinate)) {
      var direction = isVertical ? 'down' : 'right';

      var _titleOf = titleOf([1, y], coordinate, title, direction),
          _titleOf2 = _slicedToArray(_titleOf, 2),
          point = _titleOf2[0],
          text = _titleOf2[1];

      var x2 = axisOptions.x2,
          y2 = axisOptions.y2,
          horizontalDy = axisOptions.horizontalDy,
          verticalDy = axisOptions.verticalDy;
      var dy = isVertical ? verticalDy : horizontalDy;
      renderer.text({
        x: point[0] + x2,
        y: point[1] + y2,
        text: text,
        fontSize: 12,
        textAnchor: 'end',
        dy: "".concat(dy + 1, "em")
      });
    }
  }

  function axisY$1(_ref) {
    var renderer = _ref.renderer,
        scale = _ref.scale,
        values = _ref.values,
        coordinate = _ref.coordinate,
        title = _ref.title,
        _ref$tickLength = _ref.tickLength,
        tickLength = _ref$tickLength === void 0 ? 5 : _ref$tickLength;
    var ticks = ticksOf$1(values, scale, coordinate, true, 0);
    var isCircular = coordinate.isPolar() && coordinate.isTranspose();
    var isVertical = !coordinate.isTranspose();
    var axisOptions = isCircular ? axisBottomOptions(tickLength) : isVertical ? axisLeftOptions(tickLength) : axisTopOptions(tickLength);
    axis(_objectSpread2({
      renderer: renderer,
      ticks: ticks,
      values: values,
      coordinate: coordinate,
      isCircular: isCircular,
      isVertical: isVertical
    }, axisOptions));

    if (showTitle(title, coordinate)) {
      var direction = isVertical ? 'up' : 'right';

      var _titleOf = titleOf([0, 0], coordinate, title, direction),
          _titleOf2 = _slicedToArray(_titleOf, 2),
          point = _titleOf2[0],
          text = _titleOf2[1];

      var x2 = axisOptions.x2,
          y2 = axisOptions.y2,
          verticalDy = axisOptions.verticalDy,
          horizontalDy = axisOptions.horizontalDy;
      var dy = isVertical ? verticalDy : horizontalDy;
      renderer.text({
        x: point[0] + x2,
        y: point[1] + y2,
        text: text,
        fontSize: 12,
        textAnchor: 'end',
        dy: "".concat(dy - 1.5, "em")
      });
    }
  }

  var _excluded$1 = ["channel"];
  function createGuides(guidesDescriptors, scaleDescriptors, scales, encodes) {
    var guides = {};
    var ticks = {};
    var titles = {};
    var descriptors = fromObject(guidesDescriptors, function (d) {
      return d.channel;
    }, function (_ref) {
      _ref.channel;
          var rest = _objectWithoutProperties(_ref, _excluded$1);

      return _objectSpread2({}, rest);
    });
    var fields = fromObject(encodes, function (d) {
      return d.channel;
    }, function (d) {
      return d.field;
    });

    var _iterator = _createForOfIteratorHelper(scaleDescriptors),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _step.value,
            name = _step$value.name,
            options = _step$value.options;
        var descriptor = descriptors[name];
        var scale = scales[name];
        var hideTitle = descriptor && descriptor.title === false;
        var title = descriptor ? descriptor.title : undefined;

        if (display('x', name, descriptor)) {
          guides[name] = axisX$1;
          ticks[name] = ticksOf(scale, options, descriptor);
          titles[name] = hideTitle ? false : title || fields[name];
        }

        if (display('y', name, descriptor)) {
          guides[name] = axisY$1;
          ticks[name] = ticksOf(scale, options, descriptor);
          titles[name] = hideTitle ? false : title || fields[name];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return [guides, ticks, titles];
  }

  function display(target, channel, descriptor) {
    return channel === target && (!descriptor || descriptor.display === true);
  }

  function ticksOf(scale, _ref2) {
    var domain = _ref2.domain,
        _ref2$tickCount = _ref2.tickCount,
        tickCount = _ref2$tickCount === void 0 ? 5 : _ref2$tickCount;
    return scale.ticks ? scale.ticks(tickCount) : domain;
  }

  var _excluded = ["element", "data", "scale", "coordinate", "encode", "statistic", "guide", "style", "renderer"];
  function plot(_ref) {
    var geometryType = _ref.element,
        _ref$data = _ref.data,
        data = _ref$data === void 0 ? [] : _ref$data,
        _ref$scale = _ref.scale,
        scaleOptions = _ref$scale === void 0 ? [] : _ref$scale,
        _ref$coordinate = _ref.coordinate,
        transformDescriptors = _ref$coordinate === void 0 ? [] : _ref$coordinate,
        _ref$encode = _ref.encode,
        encode = _ref$encode === void 0 ? [] : _ref$encode,
        _ref$statistic = _ref.statistic,
        statisticDescriptors = _ref$statistic === void 0 ? [] : _ref$statistic,
        _ref$guide = _ref.guide,
        guidesDescriptors = _ref$guide === void 0 ? [] : _ref$guide,
        _ref$style = _ref.style,
        style = _ref$style === void 0 ? {} : _ref$style,
        customCreateRenderer = _ref.renderer,
        options = _objectWithoutProperties(_ref, _excluded);

    var index = range(data);
    var geometry = fromGeometry(geometryType);
    var channels = geometry.channels();
    var encodes = patchEncode(geometryType, encode);
    var values = valuesOf(data, encodes, channels);
    var transformedValues = applyStatistics(index, values, geometryType, statisticDescriptors);

    var _createScales = createScales(transformedValues, channels, transformDescriptors, scaleOptions),
        _createScales2 = _slicedToArray(_createScales, 2),
        scaleDescriptors = _createScales2[0],
        scales = _createScales2[1];

    var scaledValues = applyScales(transformedValues, scales);

    var _createGuides = createGuides(guidesDescriptors, scaleDescriptors, scales, encodes),
        _createGuides2 = _slicedToArray(_createGuides, 3),
        guides = _createGuides2[0],
        ticks = _createGuides2[1],
        titles = _createGuides2[2];

    var _calcDimensions = calcDimensions(ticks, titles, transformDescriptors, options),
        width = _calcDimensions.width,
        height = _calcDimensions.height,
        marginTop = _calcDimensions.marginTop,
        marginLeft = _calcDimensions.marginLeft,
        chartHeight = _calcDimensions.chartHeight,
        chartWidth = _calcDimensions.chartWidth;

    var coordinate = createCoordinate({
      x: marginLeft,
      y: marginTop,
      width: chartWidth,
      height: chartHeight,
      transforms: fromTransform(transformDescriptors)
    });
    var renderer = (customCreateRenderer || createRenderer)(width, height);
    geometry({
      index: index,
      renderer: renderer,
      values: scaledValues,
      scales: scales,
      coordinate: coordinate,
      directStyles: style
    });

    for (var _i = 0, _Object$entries = Object.entries(guides); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          guide = _Object$entries$_i[1];

      guide({
        renderer: renderer,
        scale: scales[key],
        values: ticks[key],
        coordinate: coordinate,
        title: titles[key]
      });
    }

    return renderer.node();
  }

  function defineOptions(types) {
    return Object.entries(types).reduce(function (options, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          type = _ref2[1];

      var $key = encodeKey(key);
      var name = type.name,
          defaultValue = type.defaultValue;
      options[$key] = defaultValue;

      options[key] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 0) return options[$key];

        if (name === 'array') {
          options[$key] = [].concat(_toConsumableArray(options[$key] || []), args);
        } else if (name === 'object') {
          var k = args[0],
              v = args[1];
          options[$key][encodeKey(k)] = v;
        } else {
          var _v = args[0];
          options[$key] = _v;
        }

        return options;
      };

      options[key].$setter = true;
      return options;
    }, {});
  }
  function useOptions(options) {
    if (options === undefined || options === null) return options;
    if (_typeof(options) !== 'object') return options;
    if (Array.isArray(options)) return _toConsumableArray(options.map(useOptions));
    return Object.entries(options).filter(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          value = _ref4[1];

      return !value || value && value.$setter !== true;
    }).reduce(function (obj, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          key = _ref6[0],
          value = _ref6[1];

      return obj[decodeKey(key)] = useOptions(value), obj;
    }, {});
  }

  function encodeKey(key) {
    return "$".concat(key);
  }

  function decodeKey(key) {
    return key.startsWith('$') ? key.slice(1) : key;
  }

  function item(defaultValue) {
    return {
      defaultValue: defaultValue,
      name: 'item'
    };
  }
  function array() {
    var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return {
      defaultValue: defaultValue,
      name: 'array'
    };
  }
  function object() {
    var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return {
      defaultValue: defaultValue,
      name: 'object'
    };
  }

  var Chart = {
    data: item(),
    element: item(),
    encode: array(),
    coordinate: array(),
    scale: array(),
    guide: array(),
    width: item(),
    height: item(),
    style: object(),
    statistic: array(),
    renderer: item()
  };
  var Encode = {
    channel: item(),
    field: item(),
    transform: item(),
    value: item()
  };
  var Polar = {
    type: item('polar'),
    startAngle: item(-Math.PI / 2),
    endAngle: item(Math.PI / 2 * 3),
    innerRadius: item(0),
    outerRadius: item(1)
  };
  var Transpose = {
    type: item('transpose')
  };
  var ScaleBase = {
    domain: item(),
    range: item(),
    channel: item()
  };
  var Linear = _objectSpread2(_objectSpread2({}, ScaleBase), {}, {
    tickCount: item(5),
    nice: item(false)
  });
  var Band = _objectSpread2(_objectSpread2({}, ScaleBase), {}, {
    padding: item()
  });
  var Ordinal = _objectSpread2(_objectSpread2({}, ScaleBase), {}, {
    domain: item(),
    range: item()
  });
  var Scale = _objectSpread2(_objectSpread2(_objectSpread2({}, Linear), Band), Ordinal);
  var Stack = {
    type: item('stack'),
    x: item(),
    y: item(),
    y1: item()
  };
  var AxisX = {
    display: item(true),
    channel: item('x'),
    title: item()
  };
  var AxisY = {
    display: item(true),
    channel: item('y'),
    title: item()
  };

  function interval() {
    return chart().element('interval');
  }

  function chart() {
    var options = defineOptions(Chart);

    options.plot = function () {
      return plot(useOptions(options));
    };

    return options;
  }

  function x() {
    return defineOptions(Encode).channel('x');
  }
  function y() {
    return defineOptions(Encode).channel('y');
  }
  function y1() {
    return defineOptions(Encode).channel('y1');
  }
  function fill() {
    return defineOptions(Encode).channel('fill');
  }
  function stroke() {
    return defineOptions(Encode).channel('stroke');
  }
  function label() {
    return defineOptions(Encode).channel('label');
  }
  function polar() {
    return defineOptions(Polar);
  }
  function transpose() {
    return defineOptions(Transpose);
  }
  function scale() {
    return defineOptions(Scale);
  }
  function linear() {
    return defineOptions(Linear);
  }
  function band() {
    return defineOptions(Band);
  }
  function ordinal() {
    return defineOptions(Ordinal);
  }
  function stack() {
    return defineOptions(Stack);
  }
  function axisX() {
    return defineOptions(AxisX);
  }
  function axisY() {
    return defineOptions(AxisY);
  }

  function percentage(data, key) {
    var total = data.map(key).reduce(function (sum, d) {
      return sum + d;
    });
    return function (d) {
      return key(d) / total;
    };
  }

  exports.axisX = axisX;
  exports.axisY = axisY;
  exports.band = band;
  exports.fill = fill;
  exports.interval = interval;
  exports.label = label;
  exports.linear = linear;
  exports.ordinal = ordinal;
  exports.percentage = percentage;
  exports.plot = plot;
  exports.polar = polar;
  exports.scale = scale;
  exports.stack = stack;
  exports.stroke = stroke;
  exports.transpose = transpose;
  exports.x = x;
  exports.y = y;
  exports.y1 = y1;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
